/*--Топологическая сортировка орграфа
(задание №2 в домашней работе.)*/

#include <iostream>
#include <vector>    //для массивов;
#include <fstream>   //для файлов;
using namespace std; // для пространства имён "std";

/*Основная подпрограмма алгоритма*/
int main()
{
  ifstream sourceFile;            // поток чтения файла;
  sourceFile.open("./input.txt"); // открываем файл;
  if (!(sourceFile.is_open()))    // если не открылся...;
  {
    cout << "File \"input.txt\" ne dostupen!" << endl; //...сообщаем об этом;
    sourceFile.close();                                // закрываем файл;
    return 0;                                          // прерываем подпрограмму;
  };
  /*Если файл нормально открылся...*/
  int arrayLength = 0;                                           // длина массива = его высоте;
  sourceFile >> arrayLength;                                     // читаем длину;
  cout << "Shirina i vyisota massiva = " << arrayLength << endl; // выводим на экран длину/ширину;
  int **matrix;                                                  // создаём указатель на указатель;
  matrix = new int *[arrayLength];                               // динамически создаём указатели;
  for (int i = 0; i < arrayLength; ++i)                          // обходим каждый указатель;
  {
    matrix[i] = new int[arrayLength]; // динамически заносим в каждый указатель набор элементов int;
  };
  for (int i = 0; i < arrayLength; ++i) // отображаем матрицу графа (обходим её двумерный массив);
  {
    cout << "Vershina-" << i + 1 << ": "; // выводим номер вершины;
    for (int j = 0; j < arrayLength; ++j) // обходим колонки;
    {
      sourceFile >> matrix[i][j];  // заносим элементы из файла;
      cout << matrix[i][j] << " "; // выводим на экран;
    };
    cout << endl; // сбрасываем строчку;
  };

  /*-Алгоритм топологической сортировки организованного графа
  по методу А. Кана (итеративный):
  При каждой итерации осматриваются вершины без предков,
  заносятся в очередь и исключаются из графа.-*/
  vector<int> queue;                // пустая очередь
  vector<int> tops(arrayLength, 0); // вершины, пока ноли, по ширине матрицы
  while (true)                      // бесконечный цикл;
  {
    /*удаляем, обнуляем рёбра(ссылки на вершины) тех вершин, которые есть в очереди.
    если они удаляются из графа, то не могут показывать на других*/
    for (int i = 0; i < queue.size(); ++i) // обходим очередь (если не пустая)
    {
      for (int c = 0; c < arrayLength; c++) // обходим строку матрицы
      {
        matrix[queue[i]][c] = 0; // строка матрицы - это значение из очереди (queue[i]), столбцы - вся ширина;
        /*и ставим в них ноли - если значение есть в очереди, его из матрицы удаляем, то есть все его ссылки
        на другие вершины больше не действуют (нолями становятся), и другие вершины могут стать беспредковыми,
        (то есть когда на них больше никто не показывает)*/
      };
    };
    /*теперь смотрим, на какие вершины никто не показывает.
    заносим их в массив вершин. На которые показывают - 1, на которые нет - 0.*/
    for (int i = 0; i < arrayLength; ++i) // обходим строчки матрицы
    {
      for (int j = 0; j < arrayLength; ++j) // обходим столбцы матрицы
      {
        if (matrix[i][j] == 1) // если значение в строчке матрицы = 1, (вершина ссылается на другую вершину), то...
        {
          tops[j] = 1; //...на какую вершину делается указание индексом j, по этому индексу в массиве вершин (tops)
          /*единицу поставить, то есть на эту вершину кто-то ссылается, и она не беспредковая*/
        };
        /*а там, где единица не встала, ноль в массиве вершин tops останется, это вершины беспредковые*/
      };
    };
    /*теперь те вершины в массиве вершин tops, которые 0 (беспредковые), заносим в очередь*/
    for (int i = 0; i < arrayLength; ++i) // обходим массив вершин...
    {
      if (tops[i] == 0) //...если в массиве вершин по какому-то индексу ноль лежит, то...
      {
        queue.push_back(i); //...вершина эта беспредковая, и индекс её вносим в очередь (queue).
      }
    };
    /*обнуляем весь массив вершин*/
    for (int i = 0; i < arrayLength; ++i)
    {
      tops[i] = 0;
    };
    /*те вершины, которые мы внесли в очередь, вносим единицами в массив вершин,
    тогда они при последующей перезаписи массива tops не станут нолями, и не попадут в очередь
    второй раз*/
    for (int i = 0; i < queue.size(); ++i) // обходим очередь.
    {
      tops[queue[i]] = 1; // значение из очереди делаем индексом массива вершин и даём единицу туда
    };
    /*если в массиве вершин не осталось нолей, значит все вершины в очереди*/
    int topsCount = 0;                                    // счёт вершин;
    for (topsCount; topsCount < arrayLength; topsCount++) // обходим массив вершин, смотрим, есть ли ноли
    {
      if (tops[topsCount] == 0) // если есть, то...
      {
        break; //...прерываем поиск (а если нет, то счёт сравняется с длиной массива вершин)
      }
    };
    if (topsCount >= arrayLength) // если счёт сравнялся с длиной массива (нолей не нашлось), то...
    {
      break; // прерываем цикл обхода графа.
    };
  };

  /*-Выводим на экран очередь вершин графа-*/
  cout << "topologich. obkhod vershin: "; // выводим сообщение
  for (int i = 0; i < queue.size(); i++)  // обходим очередь;
  {
    cout << queue[i] + 1 << " "; // выводим на экран число +1, поскольку массив с 0;
  };
  cout << endl; // сбрасываем строчку;

  /*очищаем память и закрываем файл*/
  sourceFile.close();                   // закрываем файл
  for (int i = 0; i < arrayLength; ++i) // обходим все указатели;
  {
    delete[] matrix[i]; // удаляем набор под каждым указателем;
  }
  delete[] matrix; // удаляем сами указатели;
  return 0;
}